[TOC]

# Interface splitting and stub generation

First, go read [OpenVRInterfaces.md](OpenVRInterfaces.md) to get an idea of what purpose this serves, and roughly what the output looks like.

## Interface splitting

The input to this whole process is a bunch of different `openvr.h` headers, one per version. These are stored in
`OpenVRHeaders/openvr-<version number>.h`. These contain all the interfaces for one OpenVR version, along
with a bunch of type and structure definitions.

A given `openvr.h` file is actually made of several headers joined together, and the names of those headers can be found
in standardised comments throughout the single header, and it looks like a tool inside Valve was used to glue the
various headers together. Unfortunately we don't have access to the original headers, so we perform header splitting,
which is reverse of this process: it takes the single big header and breaks it into a bunch of different files.

Some of those files, such as `vrtypes.h`, contain type information that is often added to but almost or completely never
changes what's already there. These files are simple: they're placed directly in `<build dir>/generated/interfaces`.

Some of those headers, however, define interfaces. Since interfaces frequently change, they're split into different
files for each version of the interface (not by OpenVR version). For example, `IVRSystem` version `022` will always end
up in `IVRSystem_022.h`, despite the fact it was originally declared in the `ivrsystem.h` file inside Valve.
If `IVRSystem` version `022` appears in multiple OpenVR versions, the latest one will be used.

Next comes namespacing: If we simply placed each copy of `IVRSystem` in its own header, since they all define a class
of the same name in the `vr` namespace they'd collide when multiple are imported at the same time. To avoid this, the
contents of each interface header are wrapped in a namespace based on the name and version of the interface.

For example, if this is the contents of an `openvr.h` header:

```c++
// vrtypes.h

// stuff here

// ivrsystem.h

namespace vr {
class IVRSystem {
public:
    // Methods here
}
static const char * const IVRSystem_Version = "IVRSystem_022";
}
```

That would get split (ignoring  `vrtypes.h`) into `IVRSystem_022.h` which would be modified to read:

```c++
namespace vr {
namespace IVRSystem_022 { // <-- This got added
class IVRSystem {
public:
    // Methods here
}
static const char * const IVRSystem_Version = "IVRSystem_022";
}
}
```

This then allows us to access the interface as `vr::IVRSystem_022::IVRSystem` (recall something like this appears in the
declaration of `CVRCompositor_012` in [OpenVRInterfaces.md]) and the previous version as `vr::IVRSystem_021::IVRSystem`
and so on. Note any structs defined in the file will have to use the same kind of namespaced access.

This is all done by `scripts/split_headers.py`. Note the stub generation script also used to be
called `generate.py` but located in `OpenOVR/Reimpl`, but nowadays it's been renamed to `stubs.py`.

### Using the interface splitter
To add a new version of OpenVR, download the header to an appropriately named file in `OpenOVR/OpenVR`,
which is `openvr-version.h`. Please always ensure the version matches.

Next, edit `scripts/split_headers.py`, adding the new version number to the `versions` list at the
top of the file. Ensure these are in the correct order - this makes sure the latest revision of any given
interface is always used (interfaces are sometimes edited without incrementing their version numbers, when
the changes don't affect the ABI - for example, adding items to an enumeration).

## Stub generation

The basic form of the interface stubs were shown in [OpenVRInterfaces.md], with the two relevant files
being `GVRCompositor.gen.h` and `stubs.gen.cpp` (both in `<build dir>/generated`). These are auto-generated
by `scripts/stubs.py`.

This script has a list of interface names (if you add a completely new interface, not just a new version of an existing
one, you must edit the script to add it). For each of those interfaces, it reads `OpenOVR/Reimpl/CVR<name>.cpp` and
parses out a few magic macros: `GEN_INTERFACE` and `BASE_FLAG`, along with looking for function definitions.

Use `GEN_INTERFACE` to tell `stubs.py` to generate a CVRInterface_xyz definitions, like so:

```c++
GEN_INTERFACE("System", "011")
GEN_INTERFACE("System", "012")
```

This then causes `stubs.py` to read the `IVRSystem_011.h` and `IVRSystem_012.h` headers (as generated by the header
splitter) and generate a declaration and definition for each of those two classes.

Use `BASE_FLAG` to add an arbitrary flag to all versions of an interface. The syntax is like so:

CVRApplications.cpp
```c++
BASE_FLAG([APPTYPE] = ~(1ull << VRApplication_Bootstrapper))
```

The APPTYPE flag is then set on all the versions of the VRApplications interface. This flag is used in `OCOVR/openvr_api.cpp` to check the valid interfaces for a given `eApplicationType`. For example, the line above prevents applications with type `VRApplication_Bootstrapper` from using the functions in the VRApplications interfaces. If they do, OpenComposite will crash and throw an error.

The `GetInterfaceFlagsByName` function (declaration in `OpenOVR/Reimpl/Interfaces.h`, definition generated by the stub generator) will get the flags associated with a given interface.

### Using the stub generator

The stub generator has a list of interfaces at the top of it's file (`scripts/stubs.py`, in the
`interfaces_list` variable). This lists each implemented interface, and there should be a corresponding
`CVR*.cpp` file for each interface. This defines which versions of the interface are to be used.

The format of the CVR ('stub definition') file is as follows:

```
#include "stdafx.h"
#define GENFILE
#include "BaseCommon.h"

GEN_INTERFACE("InterfaceName", "123")
// etc
```

(note the version **must** be exactly three digits long)

Each `GEN_INTERFACE` macro (ignored by the compiler) instructs the stub generator to generate a stub
for that interface for that file. There's no technical reason why you can't have one file generating
the stubs for many interfaces - however, by convention each stub definition file corresponds to
a single interface.

Each stub definition file causes the generation of a header - `GVR*.gen.h` ('G' in GVR for
'generated'). This header contains the class declaration for the associated stub, however it does
not contain any definitions. These classes are named `CVR*_123`, where `123` is the version.

The generator also generates a single C++ file (`stubs.gen.cpp`), which contains stub definitions for
each method in the stub, and calls the associated method on the base class.

If the generator finds a type declared in the OpenVR interface header, it takes the base name and prepends
it with `OOVR_`. Therefore, you must declare these types in your base file.

#### Overriding generated stubs

Sometimes the autogenerated stubs are unsuitable in some way. In case this happens, just add the function
definitions to the end of your stub definition file, and the generator will avoid generating it's own definition.

So, prepend this to the end of your stub definition:

```
#include "GVRMyInterface.gen.h"

void CVRMyInterface_123::MyFunc(...) {
}
```

(note that if you have a lot of arguments and you wish to insert a linebreak in
the declaration part of the function, end the line with a backslash or a comma)

The stub generator will thus not generate a stub method for `CVRMyInterface_123::MyFunc`, and your definition will
be used instead. Be careful though, as you need one function declaration per version, and with many versions this
could get messy.
